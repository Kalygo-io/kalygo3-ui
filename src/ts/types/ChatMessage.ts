/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Schema for chat messages with structured tool call outputs
 */
export interface ChatMessageV2 {
  /**
   * The role of the message sender (human or AI).
   */
  role: "human" | "ai";
  /**
   * The text content of the message.
   */
  content: string;
  /**
   * Array of tool calls made during the generation of this message. Only present for AI messages. Each tool call has a different schema depending on the tool type.
   */
  toolCalls?: (VectorSearchToolCall | VectorSearchWithRerankingToolCall | DbTableReadToolCall | DbTableWriteToolCall)[];
}
/**
 * Tool call for vector search (semantic retrieval)
 */
export interface VectorSearchToolCall {
  /**
   * The type of tool (vectorSearch)
   */
  toolType: "vectorSearch";
  /**
   * The specific tool instance name (e.g., 'search_docs')
   */
  toolName: string;
  input: {
    /**
     * The search query
     */
    query: string;
    /**
     * Number of results requested
     */
    topK?: number;
    [k: string]: unknown;
  };
  output: {
    /**
     * Search results from vector database
     */
    results: VectorSearchResult[];
    /**
     * The Pinecone namespace searched
     */
    namespace: string;
    /**
     * The Pinecone index name
     */
    index: string;
    [k: string]: unknown;
  };
}
/**
 * A single result from vector search
 */
export interface VectorSearchResult {
  /**
   * Unique vector identifier (SHA256 hash)
   */
  id: string;
  /**
   * Similarity score (0-1)
   */
  score: number;
  /**
   * Metadata structure varies by ingestion type (text/markdown vs CSV Q&A)
   */
  metadata: TextDocumentMetadata | QaMetadata;
  [k: string]: unknown;
}
/**
 * Metadata for text/markdown document chunks ingested via text_processor.py
 */
export interface TextDocumentMetadata {
  /**
   * Original filename (.txt or .md)
   */
  filename: string;
  /**
   * Chunk identifier (1-based)
   */
  chunkId: number;
  /**
   * The actual text content of this chunk
   */
  content: string;
  /**
   * Approximate token count (word-based)
   */
  chunkSizeTokens: number;
  /**
   * Upload timestamp in milliseconds (unix epoch)
   */
  uploadTimestamp: string;
  /**
   * Chunk number for display (1-based)
   */
  chunkNumber: number;
  /**
   * Total number of chunks in the document
   */
  totalChunks: number;
  /**
   * Custom YAML front matter fields from the source file (e.g., file_video_title, file_video_url)
   *
   * This interface was referenced by `TextDocumentMetadata`'s JSON-Schema definition
   * via the `patternProperty` "^file_".
   */
  [k: string]: string | number | unknown;
}
/**
 * Metadata for Q&A pairs from CSV ingestion via csv_processor.py
 */
export interface QaMetadata {
  /**
   * Row number in the CSV file (1-based)
   */
  row_number: number;
  /**
   * The question text
   */
  q: string;
  /**
   * The answer text
   */
  a: string;
  /**
   * Formatted content: 'Q: {question}\nA: {answer}'
   */
  content: string;
  /**
   * Original CSV filename
   */
  filename: string;
  /**
   * ID of the user who uploaded the file
   */
  user_id: string;
  /**
   * Email of the user who uploaded the file
   */
  user_email: string;
  /**
   * Upload timestamp in milliseconds (unix epoch)
   */
  upload_timestamp: string;
  /**
   * Creation timestamp from CSV (optional)
   */
  created_at?: string;
  /**
   * Last edit timestamp from CSV (optional)
   */
  last_edited_at?: string;
}
/**
 * Tool call for vector search with re-ranking
 */
export interface VectorSearchWithRerankingToolCall {
  /**
   * The type of tool (vectorSearchWithReranking)
   */
  toolType: "vectorSearchWithReranking";
  /**
   * The specific tool instance name (e.g., 'search_rerank_kb')
   */
  toolName: string;
  input: {
    /**
     * The search query
     */
    query: string;
    /**
     * Number of candidates retrieved before reranking
     */
    topK?: number;
    [k: string]: unknown;
  };
  output: {
    /**
     * Re-ranked search results
     */
    results: VectorSearchResult[];
    /**
     * The Pinecone namespace searched
     */
    namespace: string;
    /**
     * The Pinecone index name
     */
    index: string;
    [k: string]: unknown;
  };
}

/**
 * Tool call for database table read operations (querying structured data)
 */
export interface DbTableReadToolCall {
  /**
   * The type of tool (dbTableRead)
   */
  toolType: "dbTableRead";
  /**
   * The specific tool instance name (e.g., 'read_sessions', 'read_usage')
   */
  toolName: string;
  input: {
    /**
     * The database table being queried
     */
    table: string;
    /**
     * Columns requested (optional)
     */
    columns?: string[];
    /**
     * Query filters applied (optional)
     */
    filters?: Record<string, unknown>;
    /**
     * Maximum rows requested
     */
    limit?: number;
    [k: string]: unknown;
  };
  output: {
    /**
     * Query results as array of row objects
     */
    rows: DbReadRow[];
    /**
     * The table that was queried
     */
    table: string;
    /**
     * Total number of rows returned
     */
    rowCount?: number;
    /**
     * Column names in the result set
     */
    columns?: string[];
    [k: string]: unknown;
  };
}

/**
 * A single row from a database query result
 */
export interface DbReadRow {
  /**
   * Row identifier (if present)
   */
  id?: number | string;
  /**
   * Dynamic properties from the database row
   */
  [k: string]: unknown;
}

/**
 * Tool call for database table write operations (inserting records)
 */
export interface DbTableWriteToolCall {
  /**
   * The type of tool (dbTableWrite)
   */
  toolType: "dbTableWrite";
  /**
   * The specific tool instance name (e.g., 'create_lead', 'insert_order')
   */
  toolName: string;
  input: {
    /**
     * The database table being written to
     */
    table: string;
    /**
     * The data being inserted
     */
    data: Record<string, unknown>;
    [k: string]: unknown;
  };
  output: {
    /**
     * Whether the insert was successful
     */
    success: boolean;
    /**
     * The table that was written to
     */
    table: string;
    /**
     * The inserted record (if returned)
     */
    record?: Record<string, unknown>;
    /**
     * The ID of the inserted record (if available)
     */
    insertedId?: number | string;
    /**
     * Error message if insert failed
     */
    error?: string;
    [k: string]: unknown;
  };
}
